// SPDX-License-Identifier: AGPL-3.0-or-later
//
// Additional terms: see LICENSE-ADDITIONAL-TERMS.md

/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { PrecacheController, PrecacheRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import buildId from 'common/random_build_id';
import { getUrl } from 'common/util';
import type { MessageFromServiceWorker } from 'data/appstate/serviceWorker';
import UAParser from 'ua-parser-js';

const userAgent = UAParser(navigator.userAgent);

declare const self: ServiceWorkerGlobalScope;

export type ServiceWorkerMessage = {
  type: "SKIP_WAITING";
} | {
  type: "REGISTER_PROGRESS_PORT";
  port: MessagePort;
} | {
  type: 'STOP_TAB_HANDLING';
} | {
  type: 'CHANNEL_VISITED';
  channelId: string;
};

const webSocketStateBroadcast = new BroadcastChannel('CG_WEBSOCKET_STATE');
let socketState: Common.WebSocketState = 'disconnected';
let lastEventTime: number | undefined;
let lastDisconnect: number | undefined;
const alive = new Map<string, number>();
const tabs: {
  tabId: string;
  tabState: 'active' | 'active-throttled' | 'passive' | 'passive-throttled';
}[] = [];

const svgIconDataUrl = "data:image/svg+xml," + encodeURIComponent(`<?xml version="1.0" encoding="UTF-8"?>
  <svg width="40" height="40" fill="none" version="1.1" viewBox="0 0 40 30" xmlns="http://www.w3.org/2000/svg">
  <rect y="-5" width="40" height="40" rx="4" ry="4" fill="#404bbb"/>
  <circle cx="20.7" cy="14.664" r="13.844" stroke="#ffffff" stroke-width="1.9959"/>
  <g fill="#ffffff" stroke-width=".79586">
    <path d="m20.552 1.1311c-7.4737 0-13.532 6.0586-13.532 13.532 0 7.4737 6.0586 13.532 13.532 13.532h0.14787v-27.065zm-11.607 12.596c1.2275-1.3607 2.7904-2.4744 4.5772-2.8442 1.822-0.377 3.7737 0.04202 5.6796 1.5619l-0.99546 1.2484c-1.5711-1.2528-3.0466-1.5186-4.3606-1.2467-1.3491 0.27919-2.6309 1.1483-3.7151 2.3501z" clip-rule="evenodd" fill-rule="evenodd"/>
    <path d="m28.032 10.882c1.7868 0.36976 3.3496 1.4835 4.5772 2.8442l-1.1855 1.0696c-1.0843-1.2019-2.366-2.0709-3.7152-2.3501-1.3139-0.27195-2.7895-0.0061-4.3606 1.2466l-0.99546-1.2484c1.906-1.5199 3.8576-1.9389 5.6796-1.5619z" clip-rule="evenodd" fill-rule="evenodd"/>
    <path d="m12.469 15.088 8.3229 14.416h-16.646z"/>
  </g>
  </svg>
`);

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
const preloadData = self.__WB_MANIFEST;

// MANUALLY ADDED FILES
preloadData.push(...[
  {revision: buildId, url: '/fonts/Inter-Bold.ttf'},
  {revision: buildId, url: '/fonts/Inter-SemiBold.ttf'},
  {revision: buildId, url: '/fonts/Inter-Medium.ttf'},
  {revision: buildId, url: '/fonts/Inter-Regular.ttf'},
  {revision: buildId, url: '/audio/joinCall.mp3'},
  {revision: buildId, url: '/audio/leaveCall.mp3'},
  {revision: buildId, url: '/audio/peerJoined.mp3'},
  {revision: buildId, url: '/audio/peerLeft.mp3'},
  {revision: buildId, url: '/enable-cross-origin-security'},
  {revision: buildId, url: '/disable-cross-origin-security'},
]);

const precacheController = new PrecacheController();
precacheController.addToCacheList(preloadData);
const precacheRoute = new PrecacheRoute(precacheController);
registerRoute(precacheRoute);

let activeWorkerExistedOnStartup = self.registration.active !== null;

let handleTabStates = self.clients.matchAll({
  includeUncontrolled: false,
  type: 'window',
}).then(clients => {
  return !neverHandleTabsAgain && (
    clients.length > 0 ||
    !activeWorkerExistedOnStartup
  );
});
let neverHandleTabsAgain = false;

setInterval(async () => {
  const clients = await self.clients.matchAll({
    includeUncontrolled: false,
    type: 'window',
  });
  handleTabStates = Promise.resolve(!neverHandleTabsAgain && (
    clients.length > 0 ||
    !activeWorkerExistedOnStartup
  ));
  selectNewActiveTabIfAppropriate();
}, 2000);

function debugLog(...args: any[]) {
  // console.log(...args);
}

const bannedTabIds = new Set<string>();

self.addEventListener('install', (event) => {
  precacheController.install(event);
});
self.addEventListener('activate', (event) => {
  precacheController.activate(event);
  event.waitUntil(
    self.clients.claim().then(() => {
      return self.clients.matchAll();
    }).then(clients => {
      handleTabStates = Promise.resolve(!neverHandleTabsAgain);
      bannedTabIds.clear();
      for (const tab of tabs) {
        bannedTabIds.add(tab.tabId);
      }
      tabs.splice(0);
      socketState = 'disconnected';
      clients.forEach(client => {
        const message: MessageFromServiceWorker = { action: 'reload' };
        client.postMessage(message);
      });
    })
  )
});

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell

const excludedStarts = [
  '/files/',
  '/gated-files/',
  '/gated-videos/',
  '/api/',
  '/index_cgid.html', // for localhost/index_cgid.html
  '/push-icon',
  '/downloads',
  '/twitter-callback',
  '/enable-cross-origin-security',
  '/disable-cross-origin-security',
];
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // Exclude URLs for data retrieval
    for (const excludedStart of excludedStarts) {
      if (url.pathname.startsWith(excludedStart)) {
        return false;
      }
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  precacheController.createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html'),
  "GET"
);

// fallback mechanic for desktop devices which do not allow
// managing / accessing older notifications (experienced on linux)
const channelsWithActiveNotification = new Set<string>();

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event: Omit<ExtendableMessageEvent, 'data'> & {data: ServiceWorkerMessage}) => {
  if (event.data) {
    if (event.data.type === 'SKIP_WAITING') {
      self.skipWaiting();
    }
    else if (event.data.type === 'STOP_TAB_HANDLING') {
      neverHandleTabsAgain = true;
      handleTabStates = Promise.resolve(false);
    }
    else if (event.data.type === 'CHANNEL_VISITED') {
      const { channelId } = event.data;
      (async () => {
        const notifications = await self.registration.getNotifications({ tag: channelId });
        if (notifications.length > 0 || channelsWithActiveNotification.has(channelId)) {
          channelsWithActiveNotification.delete(channelId);
          notifications.forEach(n => n.close());
          const clients = await self.clients.matchAll({
            type: 'window'
          });
          clients.forEach(client => {
            const message: MessageFromServiceWorker = {
              action: 'channel_notification_closed',
              channelId,
            };
            client.postMessage(message);
          });
        }
      })();
    }
  }
});


// Tab WebSocket connection management

export type TabToWorkerMessage = {
  type: 'TabToWorker';
  tabId: string;
  tabState: Common.TabState | 'tabClosed';
  socketState?: Common.WebSocketState;
  lastEventTime?: number;
  lastDisconnect?: number;
};

export type WorkerToTabMessage = {
  type: 'WorkerToTab';
  tabId: string;
  tabState: Common.TabState;
  socketState?: Common.WebSocketState;
  lastEventTime?: number;
  lastDisconnect?: number;
};

async function sendTabMessage(message: WorkerToTabMessage) {
  const handleState = await handleTabStates;
  if (handleState) {
    webSocketStateBroadcast.postMessage(message);
  }
}

setInterval(async () => {
  const handleState = await handleTabStates;
  if (!handleState) {
    return;
  }

  for (const tabId of Array.from(alive.keys())) {
    const time = alive.get(tabId) as number;
    const index = tabs.findIndex(t => t.tabId === tabId);

    if (index > -1) {
      if (time < Date.now() - 70000) {
        // tab is dead
        sendTabMessage({
          type: 'WorkerToTab',
          tabId,
          tabState: 'unknown',
        });
        tabs.splice(index, 1);
      }
      else if (time < Date.now() - 4000) {
        // tab is throttled or paused
        let newTabState: 'active-throttled' | 'passive-throttled' | undefined;
        if (tabs[index].tabState === 'active') {
          newTabState = 'active-throttled';
        }
        else if (tabs[index].tabState === 'passive') {
          newTabState = 'passive-throttled';
        }
        if (!!newTabState) {
          tabs[index].tabState = newTabState;
          sendTabMessage({
            type: 'WorkerToTab',
            tabId,
            tabState: newTabState,
          });
        }
      }
    }
    else {
      alive.delete(tabId);
    }
  }

  selectNewActiveTabIfAppropriate();
}, 4000);

function selectNewActiveTabIfAppropriate() {
  if (tabs.length > 0) {
    const activeTabs = tabs.filter(t => t.tabState === 'active' || t.tabState === 'active-throttled');
    if (activeTabs.length === 0) {
      let theChosenTab = tabs.find(t => t.tabState === 'passive');
      if (!theChosenTab) {
        theChosenTab = tabs[0];
      }
      if (!!theChosenTab) {
        let newTabState: 'active' | 'active-throttled';
        if (theChosenTab.tabState === 'passive') {
          newTabState = 'active';
        }
        else {
          newTabState = 'active-throttled';
        }
        theChosenTab.tabState = newTabState;
        sendTabMessage({
          type: 'WorkerToTab',
          tabId: theChosenTab.tabId,
          tabState: newTabState,
        });
      }
      else {
        console.error("Could not select new active tab", tabs);
      }
    }
  }
}

webSocketStateBroadcast.onmessage = async (event: MessageEvent<TabToWorkerMessage>) => {
  const { data } = event;
  if (bannedTabIds.has(data.tabId)) {
    return;
  }

  const handleEvent = await handleTabStates;
  if (!!handleEvent) {
    debugLog('(SW) TabMessage received', self, event.data);
  }

  alive.set(data.tabId, Date.now());

  if (data.socketState !== undefined) {
    socketState = data.socketState;
  }

  if (data.lastEventTime !== undefined) {
    lastEventTime = data.lastEventTime;
  }

  if (data.lastDisconnect !== undefined) {
    lastDisconnect = data.lastDisconnect;
  }

  let tabIndex = tabs.findIndex(t => t.tabId === event.data.tabId);

  if (!handleEvent) {
    // only update state, but do not
    // handle event any further
    if (data.tabState === 'tabClosed') {
      bannedTabIds.add(data.tabId);
      if (tabIndex > -1) {
        tabs.splice(tabIndex, 1);
      }
    }
    else {
      const newTabState = data.tabState === 'unknown' ? 'passive' : data.tabState;
      if (tabIndex > -1) {
        tabs[tabIndex].tabState = newTabState;
      }
      else {
        tabs.push({
          tabId: data.tabId,
          tabState: newTabState,
        });
      }
    }
    debugLog('Skipped event handling');
    return;
  }

  if (data.tabState === 'tabClosed') {
    bannedTabIds.add(data.tabId);
    if (tabIndex > -1) {
      tabs.splice(tabIndex, 1);
    }
    selectNewActiveTabIfAppropriate();
    return;
  }

  const activeTabs = tabs.filter(t => t.tabState === 'active' || t.tabState === 'active-throttled');
  if (activeTabs.length > 1) {
    console.warn('More than 1 active webSocket connection tabs, this has to be a problem with the selection handling', JSON.parse(JSON.stringify(tabs)));
  }

  if (data.tabState === 'unknown') {
    let newTabState: 'active' | 'passive' = 'passive';
    if (activeTabs.length === 0) {
      // no active tab exists
      newTabState = 'active';
    }
    if (tabIndex > -1) {
      const existing = tabs[tabIndex];
      existing.tabState = newTabState;
      if (newTabState === 'active') {
        activeTabs.push(existing);
      }
    }
    else {
      const tab = {
        tabId: data.tabId,
        tabState: newTabState,
      };
      tabs.push(tab);
      tabIndex = tabs.length - 1;
      if (newTabState === 'active') {
        activeTabs.push(tab);
      }
    }
    sendTabMessage({
      type: 'WorkerToTab',
      tabId: data.tabId,
      tabState: newTabState,
      lastDisconnect,
      lastEventTime,
      socketState,
    });
  }
  else {
    if (tabIndex > -1) {
      const existing = tabs[tabIndex];
      existing.tabState = data.tabState;
    }
    else {
      tabs.push({
        tabId: data.tabId,
        tabState: data.tabState,
      });
    }
  }

  if (tabs.length === 0) {
    lastDisconnect = undefined;
    lastEventTime = undefined;
    socketState = 'disconnected';
  }
  else if (activeTabs.length === 0) {
    selectNewActiveTabIfAppropriate();
  }

  debugLog("Tabs changed", JSON.parse(JSON.stringify(tabs)));
};

// Web Push

if ('pushManager' in self.registration) {
  self.registration.pushManager.getSubscription().then(subscription => {
    console.log("ServiceWorker starting. Current push subscription:", subscription);
  });
}

self.addEventListener("push", async (pushEvent) => {
  const selfOrigin = self.location.origin;

  pushEvent.waitUntil((() => {
    const event = pushEvent.data?.json() as Events.Notification.Notification;
    console.log("SERVICE WORKER PUSH NOTIFICATION:", event);
    if (event.action === "new") {
      const data: Models.Notification.ApiNotification[] = [event.data];
      const channelId = event.data.extraData?.channelId;
      let iconUrl: string | undefined;
      
      let title: string = "";
      const alias = event.data.extraData?.userAlias;
      const { subjectUserId, subjectCommunityId } = event.data;

      if (event.data.type === 'Mention') {
        const text = alias ? `${alias} mentioned you` : 'New mention';
        title = data.length > 1 ? `${text} (+${data.length - 1} more)` : text;
        if (!!subjectUserId) iconUrl = `${selfOrigin}/push-icon?userId=${subjectUserId}`;
      }
      else if (event.data.type === 'Reply') {
        const text = alias ? `${alias} replied to you` : 'New reply';
        title = data.length > 1 ? `${text} (+${data.length - 1} more)` : text;
        if (!!subjectUserId) iconUrl = `${selfOrigin}/push-icon?userId=${subjectUserId}`;
      }
      else if (event.data.type === 'DM') {
        const text = alias ? `Message from ${alias}` : 'New message';
        title = data.length > 1 ? `${text} (+${data.length - 1} more)` : text;
        if (!!subjectUserId) iconUrl = `${selfOrigin}/push-icon?userId=${subjectUserId}`;
      }
      else if (event.data.type === 'ChannelMessage' && event.data.extraData?.type === 'channelDetailData') {
        const text = alias ? `${alias} wrote in ${event.data.extraData.communityTitle} > ${event.data.extraData.channelTitle}` : 'New message';
        title = data.length > 1 ? `${text} (+${data.length - 1} more)` : text;
        if (!!subjectUserId) iconUrl = `${selfOrigin}/push-icon?userId=${subjectUserId}`;
      }
      else if (event.data.type === 'Follower') {
        title = alias ? `${alias} is now following you` : 'New Follower';
        if (!!subjectUserId) iconUrl = `${selfOrigin}/push-icon?userId=${subjectUserId}`;
      }
      else if (event.data.type === 'Call') {
        title = 'New Call';
        if (!!subjectCommunityId) iconUrl = `${selfOrigin}/push-icon?communityId=${subjectCommunityId}`;
      }
      else if (event.data.type === 'Approval') {
        title = event.data.text;
        if (!!subjectCommunityId) iconUrl = `${selfOrigin}/push-icon?communityId=${subjectCommunityId}`;
      }
      else if (event.data.type === 'General' && event.data.extraData?.type === 'generalData') {
        title = event.data.extraData.title;
        if (!!event.data.extraData.iconUrlRelative) iconUrl = `${selfOrigin}${event.data.extraData.iconUrlRelative}`;
      }
      
      if (channelId) {
        channelsWithActiveNotification.add(channelId);
      }

      if (userAgent.os.name === 'iOS') {
        return self.registration.showNotification(title, {
          body: data.map(d => d.text).join('\n'),
          icon: iconUrl || svgIconDataUrl,
          data,
          // tag: channelId,
        });
      }
      else if (!!channelId && (event.data.type === 'ChannelMessage' || event.data.type === 'DM')) {
        return self.registration.getNotifications({ tag: channelId }).then(taggedNotifications => {
          const existingNotification = taggedNotifications[0];
          if (existingNotification && Array.isArray(existingNotification.data)) {
            for (const d of existingNotification.data) {
              data.push(d);
            }
            existingNotification.close();
          }
          return self.registration.showNotification(title, {
            body: data.map(d => d.text).join('\n'),
            icon: iconUrl || svgIconDataUrl,
            data,
            tag: channelId,
          });
        });
      }
      else {
        return self.registration.showNotification(title, {
          body: data.map(d => d.text).join('\n'),
          icon: iconUrl || svgIconDataUrl,
          data,
          // tag: channelId,
        });
      }
    }
    else {
      return self.registration.showNotification('Received unknown notification', {
        body: 'This is a bug, but we still need to display this notification to prevent your subscription from being cancelled by the browser. Please report this to us :)',
        icon: svgIconDataUrl,
        data: [{ type: 'unknown-error', extraData: undefined }],
        tag: 'unknown-notification-received',
      });
    }
  })());
});

function ensureNavigate(client: WindowClient, url: string) {
  const intervalMs = 500;
  const timeoutMs = 7000;
  let timeout: any;
  let interval: any;
  let channel: MessageChannel | undefined;

  const timeoutPromise = new Promise<void>((resolve) => {
    timeout = self.setTimeout(() => {
      self.clearInterval(interval);
      resolve();
    }, timeoutMs);
  });

  const intervalPromise = new Promise<void>((resolve) => {
    let resolved = false;
    const handler = () => {
      if (!!channel) {
        // port2 is given to the tab, so it can't be closed here
        channel.port1.close();
      }
      
      channel = new MessageChannel();
      const { port1, port2 } = channel;
      port1.onmessage = (event) => {
        // tab received event
        self.clearInterval(interval);
        self.clearTimeout(timeout);
        port1.close();
        if (!resolved) {
          resolved = true;
          resolve();
        }
      };
      const navMsg: MessageFromServiceWorker = {
        action: 'navigate',
        url,
        ackPort: port2,
      };
      client.postMessage(navMsg, [port2]);
    };
    interval = self.setInterval(handler, intervalMs);
    handler();
  });

  return Promise.race([intervalPromise, timeoutPromise]);
};

self.addEventListener('notificationclick', function(event) {
  event.notification.close(); // Close the notification

  const data: Models.Notification.ApiNotification | { type: 'unknown-error', extraData: undefined } = event.notification.data[0];
  let url: string = "/";
  if (data.type === 'Mention') {
    url = getUrl({ type: 'notification', notification: { id: data.id } });
  }
  else if (data.type === 'Reply') {
    url = getUrl({ type: 'notification', notification: { id: data.id } });
  }
  else if (data.type === 'Follower') {
    url = getUrl({ type: 'notification', notification: { id: data.id } });
  }
  else if (data.type === 'DM' && !!data.extraData && 'chatId' in data.extraData) {
    url = getUrl({ type: 'chat', chat: { id: data.extraData.chatId }});
  }
  else if (data.type === 'ChannelMessage' && !!data.extraData && data.extraData.type === 'channelDetailData' && !!data.subjectCommunityId) {
    url = getUrl({
      type: 'community-channel',
      channel: { channelId: data.extraData.channelId, url: data.extraData.channelUrl },
      community: { id: data.extraData.communityId, url: data.extraData.communityUrl },
    });
  }
  else if (data.type === 'Call' && !!data.extraData && data.extraData.type === 'callData' && !!data.subjectCommunityId) {
    url = getUrl({
      type: 'community-call',
      community: { url: data.extraData.communityUrl },
      call: { id: data.extraData.callId },
    });
  }
  else if (data.type === 'Approval' && !!data.extraData && data.extraData.type === 'approvalData') {
    url = getUrl({ type: 'community-lobby', community: { url: data.extraData.communityUrl }});
  }
  else if (data.type === 'General' && data.extraData?.type === 'generalData') {
    url = data.extraData.navUrl;
  }
  
  const channelNotificationClosed = (channelId?: string) => {
    if (channelId) {
      channelsWithActiveNotification.delete(channelId);
      const message: MessageFromServiceWorker = {
        action: 'channel_notification_closed',
        channelId,
      };
      this.setTimeout(() => {
        self.clients.matchAll({
          type: 'window',
          includeUncontrolled: true,
        }).then(clients => {
          clients.forEach(client => {
            client.postMessage(message);
          });
        });
      
      }, 500);
    }
  };

  // Use event.notification.data or other metadata to decide what URL to open
  event.waitUntil(
    self.clients.matchAll({
      type: 'window',
      includeUncontrolled: true,
    })
    .then(async (clientList) => {
      let client: WindowClient | null = null;

      // If there's at least one client, focus on it
      if (clientList.length > 0) {
        let focused = false;
        for (let i = 0; i < clientList.length; i++) {
          if (clientList[i].focused) {
            focused = true;
            client = clientList[i];
            break;
          }
        }
        if (!client) {
          client = clientList[0];
        }
        if (!focused) {
          await client.focus();
        }

        await ensureNavigate(client, url);
      }
      else {
        // If no clients are open, open a new window/tab
        client = await self.clients.openWindow(url);
      }

      return client;
    })
  );
});
